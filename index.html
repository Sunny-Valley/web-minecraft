<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Minecraft Demo</title>
    <style>
        body { margin: 0; overflow: hidden; background: #87CEEB; }
        canvas { display: block; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
</head>
<body>

<script>
// --- 游戏配置 ---
const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor: '#87CEEB', // 天空蓝背景
    physics: {
        default: 'arcade',
        arcade: {
            gravity: { y: 1000 }, // 重力设置
            debug: false
        }
    },
    scene: {
        preload: preload,
        create: create,
        update: update
    }
};

const game = new Phaser.Game(config);

// 全局变量
let player;
let cursors;
let map;
let layer;
let marker; // 鼠标高亮框
let currentTile = 2; // 当前选中的方块ID (默认是泥土)
let uiText;

// --- 1. 预加载资源 (这里我们用代码画图，代替外部图片，方便你直接运行) ---
function preload() {
    // 创建一个临时的图形对象来生成贴图
    const graphics = this.make.graphics({ x: 0, y: 0, add: false });

    // 绘制方块 1: 草方块 (顶绿底褐)
    graphics.fillStyle(0x8B4513); // 褐色
    graphics.fillRect(0, 0, 32, 32);
    graphics.fillStyle(0x32CD32); // 绿色
    graphics.fillRect(0, 0, 32, 8); // 顶部草皮
    graphics.generateTexture('tile_grass', 32, 32);
    graphics.clear();

    // 绘制方块 2: 泥土 (全褐色)
    graphics.fillStyle(0x8B4513);
    graphics.fillRect(0, 0, 32, 32);
    graphics.generateTexture('tile_dirt', 32, 32);
    graphics.clear();

    // 绘制方块 3: 石头 (灰色)
    graphics.fillStyle(0x808080);
    graphics.fillRect(0, 0, 32, 32);
    graphics.generateTexture('tile_stone', 32, 32);
    graphics.clear();

    // 绘制玩家 (蓝色方块)
    graphics.fillStyle(0x0000FF);
    graphics.fillRect(0, 0, 20, 28); // 稍微瘦一点
    graphics.generateTexture('player', 20, 28);
}

// --- 2. 创建游戏世界 ---
function create() {
    // 禁用右键菜单，方便游戏操作
    this.input.mouse.disableContextMenu();

    // --- 地图生成 ---
    // 0=空气, 1=草, 2=泥土, 3=石头
    const mapWidth = 100;
    const mapHeight = 60;
    const tileSize = 32;
    
    // 创建 Tilemap 数据
    const level = [];
    for (let y = 0; y < mapHeight; y++) {
        let row = [];
        for (let x = 0; x < mapWidth; x++) {
            // 简单的地形生成逻辑
            const surfaceY = 15 + Math.floor(Math.sin(x / 5) * 3); // 波浪地形
            
            if (y < surfaceY) {
                row.push(0); // 空气
            } else if (y === surfaceY) {
                row.push(1); // 草地
            } else if (y > surfaceY && y < surfaceY + 5) {
                row.push(2); // 泥土
            } else {
                row.push(3); // 石头
            }
        }
        level.push(row);
    }

    // 创建 Tilemap 对象
    map = this.make.tilemap({ data: level, tileWidth: tileSize, tileHeight: tileSize });
    
    // 关联刚才生成的贴图 (Phaser 需要将多个贴图添加到一个 tileset 数组中)
    // 注意：这里为了简化，我们用了 addTilesetImage 的变通方法，
    // 在正式开发中通常会用一张包含所有方块的大图 (Sprite Sheet)。
    // 这里我们强制映射：ID 1->草, 2->土, 3->石。
    // 由于 Phaser 默认处理单张大图，这里我们用一种简易方式：只渲染当前层，碰撞层逻辑通用。
    // *为了演示简单，我们下面用不同图层或者简单的颜色块逻辑，但为了物理碰撞，必须用 Tilemap*
    
    // 重新修正：为了单文件极简，我们直接用 ID 映射贴图是比较麻烦的。
    // 我们采用更简单的方式：创建一个 Tileset，把刚才生成的纹理合并（模拟）。
    // 但为了不让代码太复杂，我们这里直接加载第一张图作为 tileset，后面通过 gid 修正。
    // 实际上，为了让 Demo 跑起来不报错，我们下面这行代码有点 "Hack"，
    // 也就是我们把草地作为基础集，后续通过替换 tile 属性来模拟视觉（稍微复杂），
    // 或者：**最简单的方法** -> 我们只用一种颜色的方块做碰撞，视觉上用图片盖上去？
    // 不，最好的办法是：生成一张包含3个方块的长条图。
    
    // 补救：让我们在 create 阶段重新生成一张合图
    const atlas = this.make.graphics({x:0, y:0, add:false});
    // 画草
    atlas.fillStyle(0x32CD32); atlas.fillRect(0, 0, 32, 32); // ID 0 (Phaser内部偏移) -> 实际上是 1
    // 画土
    atlas.fillStyle(0x8B4513); atlas.fillRect(32, 0, 32, 32);
    // 画石
    atlas.fillStyle(0x808080); atlas.fillRect(64, 0, 32, 32);
    atlas.generateTexture('tileset_all', 96, 32);

    const tileset = map.addTilesetImage('tileset_all', null, 32, 32);
    layer = map.createLayer(0, tileset, 0, 0);
    
    // 设置碰撞 (所有非0方块都有碰撞)
    map.setCollisionBetween(1, 3);

    // --- 玩家设置 ---
    player = this.physics.add.sprite(100, 100, 'player');
    player.setBounce(0);
    player.setCollideWorldBounds(true); // 不掉出世界
    
    // 摄像机跟随
    this.cameras.main.setBounds(0, 0, map.widthInPixels, map.heightInPixels);
    this.cameras.main.startFollow(player);
    this.cameras.main.setZoom(1.5); // 放大一点看像素风

    // 玩家与地图碰撞
    this.physics.add.collider(player, layer);

    // --- 交互控制 ---
    cursors = this.input.keyboard.createCursorKeys(); // 箭头键
    this.wasd = this.input.keyboard.addKeys({ // WASD 键
        up: Phaser.Input.Keyboard.KeyCodes.W,
        left: Phaser.Input.Keyboard.KeyCodes.A,
        down: Phaser.Input.Keyboard.KeyCodes.S,
        right: Phaser.Input.Keyboard.KeyCodes.D
    });

    // 鼠标高亮框 (提示当前选中的格子)
    marker = this.add.graphics();
    marker.lineStyle(2, 0xFFFFFF, 1); // 白色边框
    marker.strokeRect(0, 0, map.tileWidth, map.tileHeight);

    // --- UI 界面 (固定在屏幕上) ---
    createUI(this);

    // --- 鼠标点击事件 ---
    this.input.on('pointerdown', (pointer) => {
        // 转换鼠标坐标到世界坐标 (考虑摄像机)
        const worldPoint = pointer.positionToCamera(this.cameras.main);
        
        // 找到对应的格子坐标
        const tileX = map.worldToTileX(worldPoint.x);
        const tileY = map.worldToTileY(worldPoint.y);
        const tile = map.getTileAt(tileX, tileY);

        // 计算距离（防止隔空挖矿）
        const dist = Phaser.Math.Distance.Between(player.x, player.y, worldPoint.x, worldPoint.y);
        
        if (dist < 150) { // 距离限制
            if (pointer.leftButtonDown()) {
                // 左键：破坏 (设置为空气 null)
                map.removeTileAt(tileX, tileY);
            } else if (pointer.rightButtonDown() || pointer.middleButtonDown()) {
                // 右键：放置 (如果有墙壁阻挡则不能放置，这里简化逻辑，只判断是否有方块)
                if (!tile) {
                    // 放置当前选中的方块ID
                    map.putTileAt(currentTile, tileX, tileY);
                }
            }
        }
    });

    // 键盘数字键切换物品
    this.input.keyboard.on('keydown-ONE', () => { updateUI(1); });
    this.input.keyboard.on('keydown-TWO', () => { updateUI(2); });
    this.input.keyboard.on('keydown-THREE', () => { updateUI(3); });
}

function update() {
    // --- 玩家移动逻辑 ---
    const speed = 160;
    const jumpSpeed = -450;

    if (cursors.left.isDown || this.wasd.left.isDown) {
        player.setVelocityX(-speed);
    } else if (cursors.right.isDown || this.wasd.right.isDown) {
        player.setVelocityX(speed);
    } else {
        player.setVelocityX(0);
    }

    if ((cursors.up.isDown || this.wasd.up.isDown) && player.body.onFloor()) {
        player.setVelocityY(jumpSpeed);
    }

    // --- 更新鼠标高亮框位置 ---
    const worldPoint = this.input.activePointer.positionToCamera(this.cameras.main);
    const pointerTileX = map.worldToTileX(worldPoint.x);
    const pointerTileY = map.worldToTileY(worldPoint.y);
    
    // 吸附到网格
    marker.x = map.tileToWorldX(pointerTileX);
    marker.y = map.tileToWorldY(pointerTileY);
}

// --- UI 辅助函数 ---
let uiContainer;
function createUI(scene) {
    // 创建一个 UI 容器，固定在屏幕底部
    uiContainer = scene.add.container(0, 0).setScrollFactor(0);
    
    // UI 文字
    uiText = scene.add.text(10, 10, '当前方块: 泥土 (按 1-3 切换)', { 
        font: '16px Arial', 
        fill: '#000000',
        backgroundColor: '#ffffff'
    }).setScrollFactor(0);
}

function updateUI(tileID) {
    currentTile = tileID;
    let name = "未知";
    if (tileID === 1) name = "草地";
    if (tileID === 2) name = "泥土";
    if (tileID === 3) name = "石头";
    
    uiText.setText(`当前方块: ${name} (按 1-3 切换)`);
}

</script>
</body>
</html>